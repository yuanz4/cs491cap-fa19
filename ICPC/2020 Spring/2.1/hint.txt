D: 有多个陷阱，比如考虑d.count(a) && d.count(b)的情况，并把d[a] != d[b]分出来讨论，不能erase不然之后的index会改变。在后面的合并中要用*v[d[i]].rbegin()而不能先得到该值并用其比较，否则不能过testD.in的情况。更方便的情况是直接用union find，让每个set指向最大值
E: 重点在于先设定d[i] = d[i-1] + 1。对于x_ > i中x_ - s_ > i的情况，是一种不必考虑的情况，因为x_-s_-i >= 1，在d[i] = min(d[i], x_-s_-i+d[i-1])中必定>=初始值，加不加这种情况无所谓